// src/components/Inventory/AddEditProductFormLogic.jsx
import React, { useState, useEffect, useCallback, useRef, lazy, Suspense } from 'react';
import axiosInstance from '../../api/axiosInstance';
import { useCurrency } from '../../context/CurrencyContext';
import { useDebounce } from '../../hooks/useDebounce';
import { useTranslation } from 'react-i18next';
import PropTypes from 'prop-types';
import { toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import ErrorBoundary from "../Common/ErrorBoundary";

// Importaciones desde nuestra calculadora criminal que ahora está en el frontend/utils
import {
    calculateSalePrice,
    calculateProfitAndPriceForDisplay,
} from '../../utils/currencyCalculator';

// Importación directa del componente AddEditProductForm
import AddEditProductFormUI from './AddEditProductForm';

// Define defaultNewProductState aquí, ya que es la base para la inicialización
const defaultNewProductState = {
    name: '', description: '', category: '',
    stock: '', // Cambiado a string vacío para permitir placeholder
    costPrice: '', // Cambiado a string vacío para permitir placeholder
    sku: '', unitOfMeasure: 'unidad', brand: '', supplier: '', imageUrl: '',
    color: '', size: '', material: '', variants: [],
    isPerishable: false, reorderThreshold: 0, optimalMaxStock: 0, shelfLifeDays: 0,
    profitPercentage: '', // <-- Y AQUÍ TAMBIÉN
    // Estos valores por defecto serán reemplazados por el `useEffect` basado en `exchangeRate`
    costCurrency: 'USD', saleCurrency: 'USD', baseCurrency: 'USD', displayCurrency: 'USD',
};

const AddEditProductFormLogic = ({
    isOpen,
    onClose,
    title,
    isNewProduct,
    initialProductData,
    onProductSave,
    loading,
    displayMessage,
    unitOfMeasureOptions,
    debounceTimeoutRef,
    currencyContext, // Recibimos el contexto como una sola prop
}) => {
    // Validación temprana para evitar errores
    if (!initialProductData) {
        return null;
    }

    // Usa el contexto de moneda y desestructura TODO lo que necesitas de una vez
    // ¡NUEVA PROP: availableCurrencies!
    const { exchangeRate, loadingCurrency, currencyError, fetchExchangeRate, convertPrice, formatPrice, baseCurrency: contextBaseCurrency, availableCurrencies } = currencyContext;

    // Estados internos para la lógica del formulario
    const [productData, setProductData] = useState(initialProductData || defaultNewProductState);
    const [autoGeneratedSku, setAutoGeneratedSku] = useState('');
    const [isMainSkuManuallyEdited, setIsMainSkuManuallyEdited] = useState(false);
    const [globalProductSuggestions, setGlobalProductSuggestions] = useState([]);
    const [showGlobalSuggestions, setShowGlobalSuggestions] = useState(false);
    const [noGlobalSuggestionsFound, setNoGlobalSuggestionsFound] = useState(false);
    const [imageFile, setImageFile] = useState(null);
    const [imagePreviewUrl, setImagePreviewUrl] = useState('');
    const [isUploadingMainImage, setIsUploadingMainImage] = useState(false);
    const [variantImageUploading, setVariantImageUploading] = useState({});
    const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
    const [formErrors, setFormErrors] = useState({});

    // ESTADOS PARA PORCENTAJE DE GANANCIA Y PRECIO CALCULADO (PARA LA UI)
    const [calculatedProductProfitPercentage, setCalculatedProductProfitPercentage] = useState(null);
    const [calculatedProductPricePlaceholder, setCalculatedProductPricePlaceholder] = useState(null);
    const [calculatedVariantProfitPercentage, setCalculatedVariantProfitPercentage] = useState({});
    const [calculatedVariantPricePlaceholder, setCalculatedVariantPricePlaceholder] = useState({});

    // Función para generar un SKU único a partir de un nombre
    const generateSkuFromName = useCallback((name) => {
        if (!name || name.trim() === '') return '';
        const cleanedName = name
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-zA-Z0-9\s]/g, '')
            .trim()
            .toUpperCase()
            .split(/\s+/)
            .slice(0, 4)
            .join('-');
        const hash = Math.random().toString(36).substring(2, 6).toUpperCase();
        return `${cleanedName.substring(0, 15)}-${hash}`;
    }, []);

    // Función para subir imágenes a Cloudinary (y actualizar estado del producto)
    const uploadImageToCloud = useCallback(async (fileOrUrl, isVariant = false, variantIndex = null) => {
        let uploadedUrl = '';
        const formData = new FormData();

        setFormErrors(prev => {
            const newErrors = { ...prev };
            if (isVariant) {
                newErrors[`variant-${variantIndex}-imageUrl`] = '';
            } else {
                newErrors.imageUrl = '';
            }
            return newErrors;
        });

        if (isVariant) {
            setVariantImageUploading(prev => ({ ...prev, [variantIndex]: true }));
        } else {
            setIsUploadingMainImage(true);
        }

        try {
            if (typeof fileOrUrl === 'string') {
                if (fileOrUrl.includes('res.cloudinary.com')) {
                    uploadedUrl = fileOrUrl;
                } else {
                    formData.append('imageUrl', fileOrUrl);
                    const response = await axiosInstance.post('/upload/url', formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data',
                        },
                    });
                    uploadedUrl = response.data.url;
                }
            } else {
                formData.append('image', fileOrUrl);
                const response = await axiosInstance.post('/upload', formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data',
                    },
                });
                uploadedUrl = response.data.url;
            }

            if (isVariant) {
                setProductData(prev => {
                    const updatedVariants = [...prev.variants];
                    updatedVariants[variantIndex] = { ...updatedVariants[variantIndex], imageUrl: uploadedUrl };
                    return { ...prev, variants: updatedVariants };
                });
                displayMessage('Imagen de variante subida exitosamente.', 'success');
            } else {
                setProductData(prev => ({ ...prev, imageUrl: uploadedUrl }));
                setImagePreviewUrl(uploadedUrl);
                displayMessage('Imagen principal subida exitosamente.', 'success');
            }
            return uploadedUrl;
        } catch (err) {
            console.error('Error al subir imagen:', err.response?.data?.message || err.message);
            const errorMessage = err.response?.data?.message || 'Error al subir imagen. Inténtalo de nuevo.';
            displayMessage(errorMessage, 'error');
            setFormErrors(prev => {
                const newErrors = { ...prev };
                if (isVariant) {
                    newErrors[`variant-${variantIndex}-imageUrl`] = errorMessage;
                } else {
                    newErrors.imageUrl = errorMessage;
                }
                return newErrors;
            });
            return null;
        } finally {
            if (isVariant) {
                setVariantImageUploading(prev => ({ ...prev, [variantIndex]: false }));
            } else {
                setIsUploadingMainImage(false);
            }
        }
    }, [displayMessage, setFormErrors, setProductData, setImagePreviewUrl, setIsUploadingMainImage, setVariantImageUploading]);

    // Función de validación de campos
    const validateField = useCallback((name, value, currentProductState, variantIndex = null) => {
        let error = '';
        const isVariantField = variantIndex !== null;
        const isProductSimple = currentProductState.variants.length === 0;
        const currentFieldData = isVariantField ? currentProductState.variants[variantIndex] : currentProductState;

        if (
            (name === 'name' || name === 'category' || name === 'unitOfMeasure' ||
            name === 'costPrice' || name === 'stock' || name === 'sku' ||
            name === 'baseCurrency' || name === 'costCurrency' || name === 'saleCurrency' || name === 'displayCurrency' ||
            name === 'profitPercentage') &&
            ((isProductSimple && !isVariantField) || isVariantField)
        ) {
            if (['name', 'category', 'unitOfMeasure', 'baseCurrency', 'costCurrency', 'saleCurrency', 'displayCurrency'].includes(name) && String(value).trim() === '') {
                error = `El campo ${name === 'name' ? 'nombre' : name === 'category' ? 'categoría' : name === 'unitOfMeasure' ? 'unidad de medida' : 'moneda'} es obligatorio.`;
            }

            if (name === 'sku') {
                if (isNewProduct && !isMainSkuManuallyEdited && (value === '' || value === undefined || value === null)) {
                    error = '';
                } else if (String(value).trim() === '') {
                    error = 'El SKU es obligatorio.';
                }
            }
            
            if (name === 'costPrice' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El costo unitario debe ser un número no negativo.';
            } else if (name === 'stock' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El stock debe ser un número no negativo.';
            } else if (name === 'profitPercentage' && (value === '' || isNaN(Number(value)) || Number(value) < 0 || Number(value) > 500)) {
                error = 'El porcentaje de ganancia debe ser un número entre 0 y 500.';
            }
        }

        if (currentFieldData.isPerishable) {
            if (name === 'optimalMaxStock' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El stock óptimo máximo debe ser un número no negativo.';
            }
            if (name === 'shelfLifeDays' && (value === '' || isNaN(Number(value)) || Number(value) <= 0)) {
                error = 'La vida útil debe ser un número positivo de días.';
            }
        }

        if (name === 'reorderThreshold' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
            error = 'El umbral de reaprovisionamiento debe ser un número no negativo.';
        }

        if (name === 'imageUrl' && String(value).trim() !== '' && !/^https?:\/\/.+\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(String(value))) {
            error = 'La URL de la imagen no es válida.';
        }

        return error;
    }, [isNewProduct, isMainSkuManuallyEdited]);

    // Sincroniza el estado interno con las props iniciales (para edición o nuevo producto)
    useEffect(() => {
        // Asegúrate de que las tasas de cambio estén cargadas antes de inicializar el producto
        if (loadingCurrency || !exchangeRate || !initialProductData) {
            return;
        }

        setProductData(prevData => {
            const dataToSet = { ...initialProductData };

            Object.keys(defaultNewProductState).forEach(key => {
                if (dataToSet[key] === undefined || dataToSet[key] === null || dataToSet[key] === '') {
                    dataToSet[key] = defaultNewProductState[key];
                }
            });

            if (dataToSet.profitPercentage === null || dataToSet.profitPercentage === undefined || isNaN(Number(dataToSet.profitPercentage))) {
                dataToSet.profitPercentage = exchangeRate.defaultProfitPercentage || 20;
            } else {
                dataToSet.profitPercentage = Number(dataToSet.profitPercentage);
            }

            // Establece las monedas por defecto usando las del usuario o USD
            dataToSet.costCurrency = dataToSet.costCurrency || 'USD';
            dataToSet.saleCurrency = dataToSet.saleCurrency || dataToSet.costCurrency;
            dataToSet.baseCurrency = dataToSet.baseCurrency || exchangeRate.baseCurrency || 'USD';
            dataToSet.displayCurrency = dataToSet.displayCurrency || dataToSet.saleCurrency;

            dataToSet.variants = dataToSet.variants ? dataToSet.variants.map(v => {
                if (v.profitPercentage === null || v.profitPercentage === undefined || isNaN(Number(v.profitPercentage))) {
                    v.profitPercentage = dataToSet.profitPercentage;
                } else {
                    v.profitPercentage = Number(v.profitPercentage);
                }

                return {
                    ...v,
                    costCurrency: v.costCurrency || dataToSet.costCurrency,
                    saleCurrency: v.saleCurrency || v.costCurrency,
                };
            }) : [];

            if (dataToSet.variants.length > 0) {
                dataToSet.stock = 0;
            }

            return dataToSet;
        });

        setImagePreviewUrl(initialProductData.imageUrl || '');
        setImageFile(null);
        setIsUploadingMainImage(false);
        setVariantImageUploading({});
        setShowAdvancedOptions(false);
        setFormErrors({});
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);

        setIsMainSkuManuallyEdited(initialProductData.sku?.trim() !== '');
        setAutoGeneratedSku(initialProductData.name ? generateSkuFromName(initialProductData.name) : '');

        return () => {
            if (debounceTimeoutRef.current) clearTimeout(debounceTimeoutRef.current);
        };
    }, [initialProductData, isNewProduct, generateSkuFromName, exchangeRate, loadingCurrency, debounceTimeoutRef]);

    // useEffect para recalcular los precios y porcentajes de ganancia para la UI
    useEffect(() => {
        if (loadingCurrency || !exchangeRate || !exchangeRate.conversions) {
            return;
        }

        if (productData.variants.length === 0) {
            const { salePrice, profitPercentage: actualProfit } = calculateProfitAndPriceForDisplay(
                Number(productData.costPrice),
                productData.costCurrency || 'USD',
                Number(productData.profitPercentage),
                exchangeRate,
                productData.saleCurrency || 'USD'
            );
            setCalculatedProductPricePlaceholder(salePrice);
            setCalculatedProductProfitPercentage(actualProfit);
        } else {
            setCalculatedProductPricePlaceholder(null);
            setCalculatedProductProfitPercentage(null);
        }

        const newVariantPrices = {};
        const newVariantPercentages = {};
        productData.variants.forEach((v, idx) => {
            const { salePrice, profitPercentage: actualProfit } = calculateProfitAndPriceForDisplay(
                Number(v.costPrice),
                v.costCurrency || 'USD',
                Number(v.profitPercentage),
                exchangeRate,
                v.saleCurrency || 'USD'
            );
            newVariantPrices[idx] = salePrice;
            newVariantPercentages[idx] = actualProfit;
        });
        setCalculatedVariantPricePlaceholder(newVariantPrices);
        setCalculatedVariantProfitPercentage(newVariantPercentages);

    }, [
        productData.costPrice, productData.saleCurrency, productData.costCurrency, productData.profitPercentage, productData.variants,
        exchangeRate, loadingCurrency,
    ]);

    // Manejador general para inputs del producto principal (con toda la lógica)
    const handleProductInputChange = useCallback((e) => {
        const { name, value, type, checked } = e.target;
        let inputValue = type === 'checkbox' ? checked : value;

        // CORRECCIÓN 1: Lógica para autogenerar el SKU al escribir el nombre
        if (name === 'name' && isNewProduct && !isMainSkuManuallyEdited) {
            setAutoGeneratedSku(generateSkuFromName(inputValue));
        }

        setProductData(prev => {
            const updatedData = { ...prev };

            // CORRECCIÓN 3: Guardar valores numéricos como string para permitir campos vacíos
            if (['costPrice', 'stock', 'reorderThreshold', 'optimalMaxStock', 'shelfLifeDays', 'profitPercentage'].includes(name)) {
                updatedData[name] = inputValue;
            } else {
                updatedData[name] = inputValue;
            }

            if (name === 'sku') {
                if (String(inputValue).trim() !== '') {
                    setIsMainSkuManuallyEdited(true);
                } else {
                    setIsMainSkuManuallyEdited(false);
                }
            }

            if (name === 'imageUrl') {
                setImageFile(null);
                setImagePreviewUrl(inputValue);
            }

            if (name === 'costCurrency') {
                if (prev.saleCurrency === prev.costCurrency || !prev.saleCurrency || prev.saleCurrency === 'USD') {
                    updatedData.saleCurrency = inputValue;
                }
                if (prev.displayCurrency === prev.costCurrency || !prev.displayCurrency || prev.displayCurrency === 'USD') {
                    updatedData.displayCurrency = inputValue;
                }
            }

            return updatedData;
        });
        displayMessage('', '');
        setFormErrors(prev => ({ ...prev, [name]: validateField(name, inputValue, { ...productData, [name]: inputValue }, null) }));
    }, [isNewProduct, isMainSkuManuallyEdited, generateSkuFromName, validateField, productData, displayMessage, setFormErrors, setImageFile, setImagePreviewUrl]);

    // Maneja los cambios en los campos de entrada de las variantes del producto
    const handleVariantInputChange = useCallback((index, e) => {
        const { name, value, type, checked } = e.target;
        const inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => {
            const updatedVariants = [...prev.variants];
            let updatedVariant = { ...updatedVariants[index] };

            if (['costPrice', 'stock', 'reorderThreshold', 'optimalMaxStock', 'shelfLifeDays', 'profitPercentage'].includes(name)) {
                // CORRECCIÓN 3: Guardar valores numéricos como string para permitir campos vacíos
                updatedVariant[name] = inputValue;
            } else {
                updatedVariant[name] = inputValue;
            }

            if (name === 'name') {
                if (!updatedVariant.sku || String(updatedVariant.sku).trim() === '') {
                    updatedVariant.autoGeneratedVariantSku = generateSkuFromName(inputValue);
                } else {
                    updatedVariant.autoGeneratedVariantSku = '';
                }
            } else if (name === 'sku') {
                if (String(inputValue).trim() !== '') {
                    updatedVariant.autoGeneratedVariantSku = '';
                } else {
                    if (updatedVariant.name && String(updatedVariant.name).trim() !== '') {
                        updatedVariant.autoGeneratedVariantSku = generateSkuFromName(updatedVariant.name);
                    } else {
                        updatedVariant.autoGeneratedVariantSku = '';
                    }
                }
            }

            if (name === 'costCurrency') {
                if (updatedVariant.saleCurrency === updatedVariant.costCurrency || !updatedVariant.saleCurrency || updatedVariant.saleCurrency === 'USD') {
                    updatedVariant.saleCurrency = inputValue;
                }
            }

            updatedVariants[index] = updatedVariant;
            return { ...prev, variants: updatedVariants };
        });

        setFormErrors(prev => ({
            ...prev,
            [`variant-${index}-${name}`]: validateField(name, inputValue, { ...productData, variants: productData.variants.map((v, i) => i === index ? { ...v, [name]: inputValue } : v) }, index)
        }));

        displayMessage('', '');
    }, [generateSkuFromName, validateField, productData, displayMessage, setFormErrors]);

    // Manejador para el input de tipo 'file' de la imagen principal
    const handleMainImageFileChange = useCallback(async (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFile(file);
            setImagePreviewUrl(URL.createObjectURL(file));
            setProductData(prev => ({ ...prev, imageUrl: '' }));
            setFormErrors(prev => ({ ...prev, imageUrl: '' }));
            await uploadImageToCloud(file, false, null);
        } else {
            setImageFile(null);
            setImagePreviewUrl(productData.imageUrl || '');
            setProductData(prev => ({ ...prev, imageUrl: productData.imageUrl || '' }));
        }
        displayMessage('', '');
    }, [productData.imageUrl, displayMessage, uploadImageToCloud, setFormErrors]);

    // Manejador para el evento onBlur del input de URL de imagen principal
    const handleMainImageUrlBlur = useCallback(async (e) => {
        const value = e.target.value;
        if (value && String(value).trim() !== productData.imageUrl && !String(value).includes('res.cloudinary.com')) {
            await uploadImageToCloud(value, false, null);
        }
    }, [productData.imageUrl, uploadImageToCloud]);

    // Maneja los cambios cuando se selecciona un archivo de imagen local para una variante
    const handleVariantImageFileChange = useCallback(async (index, e) => {
        const file = e.target.files[0];
        if (file) {
            await uploadImageToCloud(file, true, index);
        }
    }, [uploadImageToCloud]);

    // Añade una nueva variante al producto actual
    const handleAddVariant = useCallback(() => {
        const defaultProfitForNewVariant = productData.profitPercentage !== undefined && productData.profitPercentage !== null && !isNaN(Number(productData.profitPercentage))
            ? Number(productData.profitPercentage) : (exchangeRate ? exchangeRate.defaultProfitPercentage || 20 : 20);

        const newVariant = {
            name: '', sku: '', costPrice: '', stock: '', // <-- ¡AQUÍ ESTÁ LA MAGIA!
            unitOfMeasure: 'unidad', imageUrl: '', color: '', size: '', material: '',
            autoGeneratedVariantSku: '',
            isPerishable: false, reorderThreshold: 0, optimalMaxStock: 0, shelfLifeDays: 0,
            costCurrency: productData.costCurrency || 'USD',
            saleCurrency: productData.saleCurrency || productData.costCurrency || 'USD',
            profitPercentage: '', // <-- Y AQUÍ TAMBIÉN
        };
        setProductData(prev => ({ ...prev, variants: [...prev.variants, newVariant] }));
    }, [productData.costCurrency, productData.saleCurrency, productData.profitPercentage, exchangeRate]);

    // Función para eliminar una variante por su índice.
    const handleRemoveVariant = useCallback((indexToRemove) => {
        setFormErrors(prevErrors => {
            const newErrors = { ...prevErrors };
            Object.keys(newErrors).forEach(key => {
                if (key.startsWith(`variant-${indexToRemove}-`)) {
                    delete newErrors[key];
                }
            });
            const adjustedErrors = {};
            for (const key in newErrors) {
                const parts = key.split('-');
                if (parts[0] === 'variant' && parseInt(parts[1]) > indexToRemove) {
                    const newIndex = parseInt(parts[1]) - 1;
                    adjustedErrors[`variant-${newIndex}-${parts[2]}`] = newErrors[key];
                } else {
                    adjustedErrors[key] = newErrors[key];
                }
            }
            return adjustedErrors;
        });

        setCalculatedVariantPricePlaceholder(prev => {
            const newPrices = { ...prev };
            delete newPrices[indexToRemove];
            const adjustedPrices = {};
            Object.keys(newPrices).forEach(key => {
                const idx = parseInt(key);
                if (idx > indexToRemove) {
                    adjustedPrices[idx - 1] = newPrices[key];
                } else {
                    adjustedPrices[idx] = newPrices[key];
                }
            });
            return adjustedPrices;
        });
        setCalculatedVariantProfitPercentage(prev => {
            const newPercentages = { ...prev };
            delete newPercentages[indexToRemove];
            const adjustedPercentages = {};
            Object.keys(newPercentages).forEach(key => {
                const idx = parseInt(key);
                if (idx > indexToRemove) {
                    adjustedPercentages[idx - 1] = newPercentages[key];
                } else {
                    adjustedPercentages[idx] = newPercentages[key];
                }
            });
            return adjustedPercentages;
        });

        setProductData(prev => ({
            ...prev,
            variants: prev.variants.filter((_, index) => index !== indexToRemove)
        }));
    }, [setFormErrors, setCalculatedVariantPricePlaceholder, setCalculatedVariantProfitPercentage]);

    // Función para validar todo el formulario de producto antes del envío.
    const validateForm = useCallback((currentProductData) => {
        let errors = {};
        let isValid = true;

        const finalMainSku = isMainSkuManuallyEdited ? currentProductData.sku : (currentProductData.sku || autoGeneratedSku);

        const fieldsToValidate = ['name', 'category', 'sku', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold', 'baseCurrency', 'costCurrency', 'saleCurrency', 'displayCurrency', 'profitPercentage'];
        if (currentProductData.isPerishable) {
            fieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
        }

        const fieldsToSkipForVariantsParent = ['costPrice', 'stock', 'unitOfMeasure'];
        const effectiveFieldsToValidate = currentProductData.variants.length > 0
            ? fieldsToValidate.filter(field => !fieldsToSkipForVariantsParent.includes(field))
            : fieldsToValidate;

        effectiveFieldsToValidate.forEach(fieldName => {
            let value = currentProductData[fieldName];
            if (fieldName === 'sku') value = finalMainSku;

            if (fieldName === 'profitPercentage' && currentProductData.variants.length === 0) {
                value = calculatedProductProfitPercentage;
            } else if (fieldName === 'price' && currentProductData.variants.length === 0) {
                 value = calculatedProductPricePlaceholder;
            }

            const errorMsg = validateField(fieldName, value, currentProductData, null);
            if (errorMsg) {
                errors[fieldName] = errorMsg;
                isValid = false;
            }
        });

        currentProductData.variants.forEach((variant, index) => {
            const variantPrefix = `variant-${index}-`;
            const finalVariantSku = String(variant.sku).trim() === '' ? variant.autoGeneratedVariantSku : String(variant.sku);

            const variantFieldsToValidate = ['name', 'sku', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold', 'costCurrency', 'saleCurrency', 'profitPercentage'];
            if (variant.isPerishable) {
                variantFieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
            }

            variantFieldsToValidate.forEach(fieldName => {
                let value = variant[fieldName];
                if (fieldName === 'sku') value = finalVariantSku;

                if (fieldName === 'profitPercentage') {
                    value = calculatedVariantProfitPercentage[index];
                } else if (fieldName === 'price') {
                    value = calculatedVariantPricePlaceholder[index];
                }

                const errorMsg = validateField(fieldName, value, currentProductData, index);
                if (errorMsg) {
                    errors[`${variantPrefix}${fieldName}`] = errorMsg;
                    isValid = false;
                }
            });
        });

        setFormErrors(errors);
        return isValid;
    }, [isNewProduct, autoGeneratedSku, validateField, setFormErrors, isMainSkuManuallyEdited,
        calculatedProductProfitPercentage, calculatedProductPricePlaceholder,
        calculatedVariantProfitPercentage, calculatedVariantPricePlaceholder
    ]);

    const handleSubmit = useCallback(async (e) => {
        e.preventDefault();
        
        // CORRECCIÓN 3: Preparar los datos para el envío, convirtiendo los campos numéricos
        const productDataForSubmission = JSON.parse(JSON.stringify(productData));

        // Convertir campos del producto principal a números, usando 0 como fallback
        productDataForSubmission.stock = Number(productData.stock) || 0;
        productDataForSubmission.costPrice = Number(productData.costPrice) || 0;
        productDataForSubmission.reorderThreshold = Number(productData.reorderThreshold) || 0;
        productDataForSubmission.optimalMaxStock = Number(productData.optimalMaxStock) || 0;
        productDataForSubmission.shelfLifeDays = Number(productData.shelfLifeDays) || 0;
        // Para profitPercentage, si está vacío, debe ser null, no 0.
        productDataForSubmission.profitPercentage = productData.profitPercentage === '' ? null : Number(productData.profitPercentage);

        if (productDataForSubmission.variants.length === 0) {
            // No es necesario asignar el precio aquí, el backend lo calcula.
            // El profit percentage ya se está manejando.
        }

        productDataForSubmission.variants = productDataForSubmission.variants.map((v, idx) => {
            const updatedVariant = { ...v };
            // Convertir campos de la variante a números
            updatedVariant.stock = Number(v.stock) || 0;
            updatedVariant.costPrice = Number(v.costPrice) || 0;
            updatedVariant.reorderThreshold = Number(v.reorderThreshold) || 0;
            updatedVariant.optimalMaxStock = Number(v.optimalMaxStock) || 0;
            updatedVariant.shelfLifeDays = Number(v.shelfLifeDays) || 0;
            updatedVariant.profitPercentage = v.profitPercentage === '' ? null : Number(v.profitPercentage);
            return updatedVariant;
        });

        const isValid = validateForm(productDataForSubmission);
        if (!isValid) {
            displayMessage('Por favor, corrige los errores en el formulario.', 'error');
            return;
        }

        if (isNewProduct && !isMainSkuManuallyEdited && String(productDataForSubmission.sku).trim() === '') {
            productDataForSubmission.sku = autoGeneratedSku;
        }

        // El backend ya no necesita el precio calculado, lo genera él mismo.
        // Limpiamos los campos que no deben llegar al backend para evitar confusiones.
        if (productDataForSubmission.variants.length === 0) {
            delete productDataForSubmission.price;
        } else {
            productDataForSubmission.variants = productDataForSubmission.variants.map(v => {
                const newVariant = { ...v };
                delete newVariant.autoGeneratedVariantSku;
                return newVariant;
            });
            delete productDataForSubmission.stock;
            delete productDataForSubmission.costPrice;
        }

        await onProductSave(productDataForSubmission);
    }, [onProductSave, productData, validateForm, displayMessage, isNewProduct, isMainSkuManuallyEdited, autoGeneratedSku,
        calculatedProductPricePlaceholder, calculatedProductProfitPercentage, calculatedVariantPricePlaceholder, calculatedVariantProfitPercentage
    ]);

    // Maneja la selección de un producto desde las sugerencias del catálogo global.
    const handleSelectGlobalProduct = useCallback((suggestedProduct) => {
        setProductData(prev => {
            const newProductData = {
                ...prev,
                name: suggestedProduct.name,
                description: suggestedProduct.description || '',
                category: suggestedProduct.category || '',
                sku: suggestedProduct.sku || '',
                unitOfMeasure: suggestedProduct.unitOfMeasure || 'unidad',
                brand: suggestedProduct.brand || '',
                supplier: suggestedProduct.supplier || '',
                imageUrl: suggestedProduct.imageUrl || '',
                color: suggestedProduct.color || '',
                size: suggestedProduct.size || '',
                material: suggestedProduct.material || '',
                isPerishable: suggestedProduct.isPerishable || false,
                reorderThreshold: suggestedProduct.reorderThreshold || 0,
                optimalMaxStock: suggestedProduct.optimalMaxStock || 0,
                shelfLifeDays: suggestedProduct.shelfLifeDays || 0,

                baseCurrency: suggestedProduct.baseCurrency || 'USD',
                costCurrency: suggestedProduct.costCurrency || 'USD',
                saleCurrency: suggestedProduct.saleCurrency || 'USD',
                displayCurrency: suggestedProduct.displayCurrency || suggestedProduct.saleCurrency || 'USD',
                profitPercentage: suggestedProduct.profitPercentage !== undefined && suggestedProduct.profitPercentage !== null && !isNaN(Number(suggestedProduct.profitPercentage))
                    ? Number(suggestedProduct.profitPercentage) : (exchangeRate ? exchangeRate.defaultProfitPercentage || 20 : 20),

                price: suggestedProduct.price || 0,
                costPrice: suggestedProduct.costPrice || 0,

                variants: suggestedProduct.variants ? suggestedProduct.variants.map(v => ({
                    ...v,
                    autoGeneratedVariantSku: v.sku && String(v.sku).trim() !== '' ? '' : generateSkuFromName(v.name || ''),
                    isPerishable: v.isPerishable || false,
                    reorderThreshold: v.reorderThreshold || 0,
                    optimalMaxStock: v.optimalMaxStock || 0,
                    shelfLifeDays: v.shelfLifeDays || 0,
                    costCurrency: v.costCurrency || 'USD',
                    saleCurrency: v.saleCurrency || v.costCurrency || 'USD',
                    profitPercentage: v.profitPercentage !== undefined && v.profitPercentage !== null && !isNaN(Number(v.profitPercentage))
                        ? Number(v.profitPercentage) : (suggestedProduct.profitPercentage !== undefined && suggestedProduct.profitPercentage !== null && !isNaN(Number(suggestedProduct.profitPercentage))
                            ? Number(suggestedProduct.profitPercentage) : (exchangeRate ? exchangeRate.defaultProfitPercentage || 20 : 20)),
                    price: v.price || 0,
                    costPrice: v.costPrice || 0,
                })) : [],
            };

            return newProductData;
        });

        setImageFile(null);
        setImagePreviewUrl(suggestedProduct.imageUrl || '');
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setAutoGeneratedSku(suggestedProduct.name ? generateSkuFromName(suggestedProduct.name) : '');
        setIsMainSkuManuallyEdited(suggestedProduct.sku?.trim() !== '');
        setFormErrors({});
        displayMessage('Producto global cargado. Puedes modificarlo y guardarlo como nuevo.', 'info');
    }, [generateSkuFromName, displayMessage, exchangeRate]);

    return (
        <ErrorBoundary>
            <AddEditProductFormUI
                    isOpen={isOpen}
                    onClose={onClose}
                    title={title}
                    isNewProduct={isNewProduct}
                    productData={productData}
                    onProductDataChange={setProductData}
                    onSubmit={handleSubmit}
                    loading={loading || loadingCurrency}
                    displayMessage={displayMessage}
                    autoGeneratedSku={autoGeneratedSku}
                    isMainSkuManuallyEdited={isMainSkuManuallyEdited}
                    setIsMainSkuManuallyEdited={setIsMainSkuManuallyEdited}
                    imageFile={imageFile}
                    setImageFile={setImageFile}
                    imagePreviewUrl={imagePreviewUrl}
                    setImagePreviewUrl={setImagePreviewUrl}
                    isUploadingMainImage={isUploadingMainImage}
                    variantImageUploading={variantImageUploading}
                    setVariantImageUploading={setVariantImageUploading}
                    uploadImageToCloud={uploadImageToCloud}
                    unitOfMeasureOptions={unitOfMeasureOptions}
                    formErrors={formErrors}
                    setFormErrors={setFormErrors}
                    generateSkuFromName={generateSkuFromName}
                    globalProductSuggestions={globalProductSuggestions}
                    showGlobalSuggestions={showGlobalSuggestions}
                    setShowGlobalSuggestions={setShowGlobalSuggestions}
                    setNoGlobalSuggestionsFound={setNoGlobalSuggestionsFound}
                    noGlobalSuggestionsFound={noGlobalSuggestionsFound}
                    handleSelectGlobalProduct={handleSelectGlobalProduct}
                    debounceTimeoutRef={debounceTimeoutRef}
                    setShowAdvancedOptions={setShowAdvancedOptions}
                    showAdvancedOptions={showAdvancedOptions}
                    handleAddVariant={handleAddVariant}
                    handleRemoveVariant={handleRemoveVariant}
                    handleProductInputChange={handleProductInputChange}
                    handleVariantInputChange={handleVariantInputChange}
                    handleMainImageFileChange={handleMainImageFileChange}
                    handleMainImageUrlBlur={handleMainImageUrlBlur}
                    handleVariantImageFileChange={handleVariantImageFileChange}
                    calculatedProductProfitPercentage={calculatedProductProfitPercentage}
                    calculatedProductPricePlaceholder={calculatedProductPricePlaceholder}
                    calculatedVariantProfitPercentage={calculatedVariantProfitPercentage}
                    calculatedVariantPricePlaceholder={calculatedVariantPricePlaceholder}
                    formatPrice={formatPrice}
                    convertPrice={convertPrice}
                    exchangeRate={exchangeRate}
                    availableCurrencies={availableCurrencies}
                />
        </ErrorBoundary>
    );
};

AddEditProductFormLogic.propTypes = {
    isNewProduct: PropTypes.bool.isRequired,
    initialProductData: PropTypes.object.isRequired,
    onProductSave: PropTypes.func.isRequired,
    loading: PropTypes.bool.isRequired,
    displayMessage: PropTypes.func.isRequired,
    unitOfMeasureOptions: PropTypes.array.isRequired,
    debounceTimeoutRef: PropTypes.object.isRequired,
};

export default AddEditProductFormLogic;